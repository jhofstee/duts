
global _context_kernel_prompt _context_kernel_image cur_context TIMEOUT
global CFG_ROOTPATH

##
## Check rootpath 
##
if ![info exists CFG_ROOTPATH] {
	p_err "variable CFG_ROOTPATH is not set, please update the\
	       .tgt definition file for your board"
	       return 0
} else {
	p_verb "CFG_ROOTPATH '$CFG_ROOTPATH'"
	if ![valid_dir $CFG_ROOTPATH] {
		p_err "problem validating rootpath: '$CFG_ROOTPATH'"
		return 0
	}
}

##
## Check if we have kernel file to load
##
if ![valid_file $_context_kernel_image] {
	p_err "problems with kernel file '$_context_kernel_image'?!"
	return 0
}

##
## Set kernel file name to boot
##
set rv [_context_firmware_command "setenv bootfile $_context_kernel_image" ".*"]
if {!$rv} {
	return 0
}

##
## Set rootpath 
##
set rv [_context_firmware_command "setenv rootpath $CFG_ROOTPATH" ".*"]
if {!$rv} {
	return 0
}

##
## net_nfs
##
expect "*"
send -s "run net_nfs\r"
expect {
	timeout {
		p_err "timed out after 'bootcmd'"
		return 0
	}
	"Bad Magic Number" {
		p_err "problems finding image?!"
		return 0
	}
	"Linux version" {
		set cur_context "kernel"
		set timeout 300

		expect {
			timeout {
				p_err "timed out while waiting for login prompt"
				return 0
			}
			-re ".*Kernel\\ panic" {
				##
				## This is really bad - we cannot be sure if
				## the crash does not confuse test cases that
				## were scheduled for execution after this one.
				##
				p_err "PANIC!"
				if [ask_yesno "continue execution? "] {
					return 0
				} else {
					exit1
				}
			}
			"login: " {
				p_verb "login prompt OK"
			}
		}

		set timeout $TIMEOUT 
		send -s "root\r"
		expect {
			timeout {
				p_err "timed out while waiting for kernel prompt"
				return 0
			}
			-re ".*$_context_kernel_prompt" {
				return 1
			}
		}	
	}
}
