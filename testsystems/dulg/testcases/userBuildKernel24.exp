#
# Build 2.4 kernel 
#

global _context_host_prompt _context_host_shell TIMEOUT
global board_name a_devices timeout env

set eldk_path "/opt/eldk-3.1.1/usr/bin/"

set kernel_dir "linuxppc_2_4_devel"
set kernel_repo "/home/git/$kernel_dir"
set kernel_src "~/git/$kernel_dir-duts"

set cur_dir [pwd]

set prompt $_context_host_prompt
set p [string map {"]" "\\]" "$" "\\$" " " "\\ "} $prompt]
set shell $_context_host_shell

##
## spawn shell
##
expect "*"
if [catch {spawn $shell}] {
	p_err "couldn't spawn '$shell' command" 1
}
expect {
	$prompt { p_verb "shell prompt OK" }
	timeout {
		p_err "couldn't get '$prompt' shell prompt"
		set timeout $TIMEOUT
		return
	}
}

##
## clone kernel tree repo
##

# closing strings:
# Cloned to linuxppc_2_4_devel/ (origin /home/git/linuxppc_2_4_devel available as branch "origin")
set cmd "cg-clone $kernel_repo $kernel_src"
set timeout 300
send -s "$cmd\r"
expect {
	-re ".*Cloned\\ to\\ .*$p" {
		p_verb "'$cmd' OK"
	}
	-re ".*already\\ exists.*$p" {
		p_warn "Repo '$kernel_src' exists!"
	}
	timeout {
		p_err "Timed out after '$cmd'"
		set timeout $TIMEOUT
		return
	}
}

##
## get make target name for our board
##
set target $a_devices($board_name,maketarget) 

##
## set env vars for the build: ARCH, CROSS_COMPILE
##
set env(ARCH) $a_devices($board_name,makearch)
set env(CROSS_COMPILE) $a_devices($board_name,makecompile)

##
## set PATH so the desired ELDK toolchain is selected
##
if ![valid_dir $eldk_path] {
	p_err "Problems accessing '$eldk_path' dir..?!"
	return
}
set path $env(PATH)

set pl [split $path ":"]
set pl_new {}

set len [llength $pl]
for {set i 0} {$i < $len} {incr i} {
	set el [lindex $pl $i]
	if [string match *eldk* $el] {
		# there's already a path to ELDK - change it to the desired
		set pl_new [lreplace $pl $i $i $eldk_path]
	}
}
if [llength $pl_new] {
	set path_new [join $pl_new ":"]
} else {
	# if there is no updated path list it means there was no eldk found in
	# the current PATH so we need to add it
	lappend pl $eldk_path
	set path_new [join $pl ":"]
}
# now we can set the [new] PATH
set env(PATH) $path_new


##
## change dir to kernel src tree
##
if ![valid_dir $kernel_src] {
	p_err "Problems accessing '$kernel_src' dir..?!"
	return
}
cd $kernel_src

##
## mrproper
##
set timeout 180
_context_host_command "make mrproper" ".*Leaving directory.*Documentation/DocBook.*"


##
## make ..._config
##
set timeout $TIMEOUT 
_context_host_command "make ${target}_config" ".*cp -f.*arch/.*/defconfig.*"


##
## spawn shell - this is a second shell as we changed dir to the newly cloned 
## dir and the previously spawned shell wouldn't know about it
##
expect "*"
if [catch {spawn $shell}] {
	p_err "couldn't spawn '$shell' command" 1
}
expect {
	$prompt { p_verb "shell prompt OK" }
	timeout {
		p_err "couldn't get '$prompt' shell prompt"
		set timeout $TIMEOUT
		return
	}
}

##
## make oldconfig
##
set cmd "make oldconfig"
set timeout 120
send -s "$cmd\r"
#exp_internal 1
expect {
	-re ".*End of Linux kernel configuration.*$p" {
		p_verb "'$cmd' OK"
	}
	-re ".*\\ \\(NEW\\)\\ " {
		send -s "\r"
		exp_continue	
	}
	-re ".*No\\ rule\\ to\\ make\\ target.*Stop.*" {
		p_err "No rule?!"
		set timeout $TIMEOUT
		return
	}
	timeout {
		p_err "Timed out after '$cmd'"
		set timeout $TIMEOUT
		return
	}
}


##
## make dep
##
set timeout 300
set cmd "make dep"
send -s "$cmd\r"

# closing strings are:
# scripts/mkdep -- init/*.c > .depend
# + shell prompt 
expect {
	-re ".*scripts/mkdep\\ --\\ init/\\*\\.c\\ >\\ \\.depend.*$p" {
		p_verb "'$cmd' OK"
	}
	timeout {
		p_err "Timed out after '$cmd'"
		set timeout $TIMEOUT
		return
	}
}

##
## make uImage
##

set timeout 600
set cmd "make uImage"
send -s "$cmd\r"

# closing strings are: 
#
# ln -sf vmlinux.UBoot images/uImage
# rm -f ./mkuboot
# make[1]: Leaving directory `/.automount/castor-vlab/root/home/raj/git/linuxppc_2
# _4_devel/arch/ppc/boot'
#
# errror strings:
#
# host/ehci-q.c:185: error: invalid storage class for func
# make[3]: *** [host/ehci-hcd.o] Error 1
expect {
	-re ".*ln\\ -sf\\ vmlinux\\.UBoot\\ images/uImage.*$p" {
		p_verb "'$cmd' OK"
	}
	-re ".*:\\ error:.*" {
		p_err "failed in '$cmd'"
		set timeout $TIMEOUT
		return
	}
	-re ".*make.*\\ Error\\ .*" {
		p_err "failed in '$cmd'"
		set timeout $TIMEOUT
		return
	}
	timeout {
		p_err "Timed out after '$cmd'"
		set timeout $TIMEOUT
		return
	}
}

##
## copy image to tftpboot dir
##
set dest_dir "/tftpboot/$board_name/"
set dest_name "uImage-24-duts"
if ![valid_dir $dest_dir] {
	p_err "Problems with '$dest_dir' image directory?!"
	return
}
set cmd "cp arch/$a_devices($board_name,makearch)/boot/images/uImage $dest_dir/$dest_name"
if [catch {set o [eval exec $cmd]}] {
        p_err "couldn't execute '$cmd'" 1
}
send_user $o


cd $cur_dir
unset cur_dir
unset prompt

# reset default timeout
set timeout $TIMEOUT
return
