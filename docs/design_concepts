1. Intro.

This summary describes the basics of DUTS, the DENX Universal Test System, a
framework for testing U-Boot and Linux kernel in the embedded environment.

Terminology note: test framework (or just framework), test system are all
equivalent to DUTS if not stated otherwise. TC = test case, TG = test group.

General assumptions.

* geared towards command line interface testing

* easy to use and flexible (user can run selected test case(s) against a given
board or a set of boards)

* extensible i.e. easy to add a new test case, modify existing etc.

* scalable (easy to run against a set of boards, simultaneously if needed)

* uses custom scripts system based on expect/Tcl


2. Overview.

Within the framework the central entity is a test case (TC): a sequential
execution flow of chosen commands in logical association, for example writing
to memory and subsequent reading for verification. Quite often a "sequence"
has only one command in the flow.

Test group (TG) is simply a list of certain test cases, that must be
implemented before "grouping"; for example TG 'eeprom' groups a number of test
cases, each performing read, write and other operations on the device. Please
refer to testgroups/example.test_group for an example.

Test cases can be executed individually as well as a test group (list)
sequence. In the latter case TCs are executed in the order of the TG. Test
groups are meant to help group TCs and ease automation; it can also stand a
simple mechanism for supporting user-defined hierarchy, but are not required
for operation. 

Note that all references to 'execution' of test cases and groups throughout
this summary are meant in the context of the test framework and via the
end-user tool (refer to p.4). Test cases are not proper (stand alone)
executable scripts.

Test cases are run against a target _device_ and within a specific _context_,
which are the key abstractions used to model the test environment:

* device
  
  represents a physical target device, so every target to be supported needs
  to have a specific implementation of such entity; associated with a device
  must be a pointer to low-level 
  
  a number of user-defined
  variables can be associated with a device
  
  among others the device
  implements methods for the following operations on the target:
  
  - power on/off
  - connect to target
  - return current context (state) of the device

  The default implementation of operations on devices in DENX VL is stored in
  testsystems/common/devices/VL_devices.tcl.

 
* context (a.k.a. state)

  describes a stable state the device can be in; currently the framework
  recognizes the following context _classes_
  
  - off (device is idle, powered off)
  - firmware (device is running firmware, waiting with user prompt for commands)
  - kernel (device is running OS, waiting with user prompt for commands)
  
  A particular configuration (e.g. firmware = U-Boot, kernel = Linux etc.) 
  needs to implement specific behaviours for context classes; among others they
  have the following methods:

  - handler (the main function called when entering the context)
  - command (responsible for sending a command and receiving response)
  - helper params (image file name, prompt)
  
  The default implementation of context methods (for U-Boot, Linux) is stored
  respectively, in:
  
	  testsystems/common/config/VL_uboot_context.tcl
	  testsystems/common/config/VL_linux_context.tcl

  and bound to configuration views in:

	  testsystems/common/config/VL_configs.cfg

When adapting DUTS to work for other environments, a separate implementation
or extensions of the above abstractions is required.


3. Test cases basics.

3.1. Sections.

Each test case it described by a series of sections, with a mandatory set
required in every TC. Please refer to testcases/example.test_case for detailed
descriptions of ALL sections and their attributes, below are highlighted only
the commonly used.

The most important sections from the perspective of a test system
developer/user are the following:

  Commands (mandatory)
  Pre (optional)
  Post (optional)

There can be only one of each of these per TC and each contains a series of
commands and expected outputs, or specifies an external executable to be
invoked by the framework. Actions specified in Pre and Post sections are
performed before and after actions in Commands section, respectively.
Additional feature of Pre/Post is their flows are not logged to the TC's log
file (see 2.3). They are meant to allow for preparation before the proper TC
actions and cleaning up after wards.

3.2. External expect scripts.

Instead of specifying test cases flow by the sequence of inputs and expected
outputs as described earlier, the user can provide a pointer to external script
with custom contents that is invoked by the framework. This allows for more
non standard test cases and a way to extend the framework.

There can be only one external script specified in a given Pre,
Commands or Post section.

3.3. Logging.

The flow of each test case (inputs sent and outputs received during TC's
execution) is captured in a log file, by default named after the test case's
name (this can be changed by a Logfile section): each test case is thus
accompanied by a log file with its execution record.

3.4. Type.

Each test case is assigned to a context as mentioned in the overview. The Type
field is the connection point between a test case and a particular context
implementation. The context that a given test case relies on must be specified
in a duts_config structure and this configuration view must be selected (-c)
when running the test case.


4. Implementation notes

4.1. Test system directories outline

<duts dir>/
	  /include
	  /testsystems/dulg
	                   /config
			   /devices
			   /testcases
			             /file1.tc
				     /file2.tc
			   /testgroups
			              /1.tg
				      /2.tg

- testsystems - contains sub-directories with logically complete packages of
  devices, config (including contexts) descriptions along with test cases
  (groups) implementation. For example testcases and surroundings needed to
  generate DULG manual includes are placed in 'testsystems/dulg' directory, an
  imaginary package for stress testing U-Boot could have a 'stress' subdir
  etc.

- include - library of routines that implement core DUTS functionality, no
  standalone scripts, only used by the main 'duts' tool

- duts - the main end user tool


5. Usage

When the main 'duts' tool is ordered to run test cases, they are executed
against a certain device (board), and while many TCs are supposed to be
uniform across different boards and CPU architectures, some may require
board-specific handling (and hence proprietary implementation). 

Upon startup 'duts' searches the default test cases directory and reads in all
definitions found, then builds internal representation for further processing;
when a sub-directory is found with the name of the current board target it is
also searched for board-specific test cases, and if exist they are also
included.

Note DUTS does not check for test cases' names (definitions) conflicts: if
multiple definitions of a TC exist with the same name, the last one prevails.
This allows for some form of overloading, e.g. there can be a generic test
case used for most of the boards, with a custom implementation for some, all
with just one name the operator can use for all boards, in a test group etc.

All operations are performed within a working directory, which by default is
<duts_dir>/testsystems/dulg, but can be changed with -d option.

5.1. End user operation

The central point from usability perspective is the highest level
user-executable (script) tool which is the only interface the test system
consumer is given for using the framework. Among other tasks it allows the
operator to do the following:

- run test case (list of TCs) against a specified board
- list implemented test cases
- list available/supported boards
- list configuration for a given board (board name, addresses, path to images 
location etc.)

5.2. Commands and options

  * list implemented test cases
  ./duts [options] lt [board name]

  when board name is supplied lists board-specific TCs, without parameter
  common (shared) test cases are listed

  * display target device details
  ./duts [options] b <board name>

  * list available/supported boards
  ./duts [options] b

  * display configuration view details
  ./duts [options] c <config>

  * list available configs
  ./duts [options] c


  * run test cases

    individually selected
    ./duts [options] t <board name> -t <tc1> <tc2> <tc3> ... <tcN>

    all defined TCs
    ./duts [options] t <board name>

    from file list (test group)
    ./duts [options] t <board name> <text file 1>...<text file N>

    selecting config view (other than default)
    ./duts [options] t <board name> -c <config>


  options:
    -d <alternative working dir> (default is <duts_dir>/testsystems/dulg)

    -l <alt dir for log storage> only for "t" command i.e. only when there is
    something to log (default is <duts_dir>)

5.3. Adding a new TC

For a new test case test developer is required to get familiar with
descriptions in <duts_dir>/docs/example.tc and implement according to
guidelines given therein, the TC then needs to be copied to
<testsystem_dir>/testcases sub-dir in order for 'duts' tool to access it.

5.4. Adding support for a new board

When adding support for a new target device, test developer is required to get
familiar with descriptions in <duts_dir>/docs/example.tgt and implement a new
file with duts_device description, or just add it to an existing .tgt file
(like amcc.tgt or tqm.tgt and the like). In order for DUTS to recognized the
newly added or modified files they need to be placed in:

testsystems/<testsystem>/device or
testsystems/common/device

5.5 Context (state) management internals
TODO

OFF-->FIRMWARE-->KERNEL-.
 ^       ^              |
 |_______|______________|

