#!/bin/env expect
#
# (C) Copyright 2006
# Wolfgang Denk, DENX Software Engineering, wd@denx.de
#
#

set BASE_DIR "/home/raj/git/duts/"


##
## include helper procedures
##
source "$BASE_DIR/include/lib.tcl"

#
# ./get_src [<config>] [-t <SCM type>] [-n <repo_name>] [-s <repo_src>] 
#	[-d <repo_dst>] [-p <other params>] [-to <timeout>] [-nc]
#
# [<config>] - config label
# [-t <SCM type>] - id of supported scm (git, cvs)
# [-n <repo_name>] - name in the repo (u-boot, linuxppc_2_4_devel, linux-2.6-denx etc.)
# [-s <repo_src>] - repo location (/home/git)
# [-d <repo_dst>] - dest location (./u-boot_copy etc.)
# [-p <other repo params>] (private data e.g. branch ID for 'git' SCM type)
# [-to <timeout>] - timeout in seconds for repo op to complete
#
# [-b]	- batch mode, no user confirmation
# [-v]	- verbose
#
#
#  examples:
# ./get_src -n linuxppc_2_4_devel -t git -s /home/git/ -d linuxppc_2_4_devel_copy -p [branchID]
#
# ./get_src -s /git/duts/ -d old_duts -p 373d8583b609f378dd6b81d7d45aef97e6ada526
#
# ./get_src linux24 - uses 'linux24' predefined config
# ./get_src [empty params] - uses default config
#

##
## default values
##
set verbose "no"
set confirm "yes"

set scm_config ""
set scm_handler ""

set TIMEOUT 10

set shell_prompt ""
set shell_sid ""

#
# table of supported SCM schemes, each element is
# {<handler_function> "<name>"}
#
# <name> is the label for use in '-t' command line option or 'scm_type' field 
# in config file
#
set scm_supported {
	{do_git "git"}
	{do_cvs "cvs"}
	{do_local "local"}
}

#
# table of user interface options, each element is
# {<global_var_name> "<opt_string>" "<default_value>"}
set opt_table {
	{repo_type "t" "git"}
	{repo_name "n" "u-boot"}
	{repo_src "s" "/home/git/"}
	{repo_dst "d" ""}
	{repo_params "p" ""}
	{scm_timeout  "to" "180"}
}

#
# dumps params
#
proc show_params {} {
	
	global opt_table
	set globals [list]

	# create list of global vars names from opt table
	foreach o $opt_table {
		set var_name [lindex $o 0]
		lappend globals $var_name
	}

	# add other interesting global vars to the list
	lappend globals "confirm" "verbose" "scm_config"

	puts "--- Settings ---"
	foreach g $globals {
		global $g
		puts "$g = '[subst $$g]'"
	}
}

#
# checks if the path to repo $r is accessible and resembles GIT, returns 0/1
#
proc git_valid_repo {r} {

	set rv 1

	if ![valid_dir $r] {
		p_verb "problems accessing source GIT repo: '$r'?!"
		set rv 0
	} else {
		# check if .git present in the src dir
		if ![file exists $r/.git] {
			p_verb "doesn't look like GIT repo: '$r'?!"
			set rv 0
		}
	}
	
	return $rv
}

#
# checks the src GIT repo specified, returns 0/1.
#
# GIT src can be specified in the following conventions:
# "-s /home/git/ -n u-boot"
#
# "-s /home/git/u-boot"
#
# after this f. returns successfully we have a final effective path to the GIT
# repo directory in global $repo_src e.g. /home/git/u-boot,
# /home/git/linux-2.6-denx etc. and a repo name alone in the $repo_name e.g. 
# u-boot, linux-2.6-denx etc.
#
proc git_valid_src {} {

	global repo_src repo_name
	set rv 1

	# default dir (used when specified null)
	set repo_src_def "."

	set repo_src [string trimright $repo_src "/"]

	if {($repo_src == "") && ($repo_name == "")} {
		p_err "source repo parameters null, use -s/-n options to\
		specify GIT source location"
		return 0
	}
	
	if {$repo_src == ""} {
		set repo_src $repo_src_def 
	}

	if [git_valid_repo $repo_src] {
		# we have a legitimate GIT repo, use it
		if {$repo_name != ""} {
			p_verb "redundant GIT repo specification: repo src\
			location is used: '$repo_src', and \[redundant\] name\
			specification is discarded: '$repo_name'"
			set repo_name ""
		} else {
			# everything ok, set current $repo_name for later use
			set repo_name [file tail $repo_src]
		}
	} else {
		if {$repo_name == ""} {
			set rv 0
		} else {
			set repo_src "$repo_src/$repo_name"
			if ![git_valid_repo $repo_src] {
				set rv 0
			}
		}
	}
	if {!$rv} {
		p_err "problems accessing GIT repo: '$repo_src'"
	}

	return $rv
}

#
# checks GIT dest location - it can be specified in the following conventions:
#
# "-d <some_dir>/<name>" e.g. for U-Boot: -d ~/u-boot.mycopy
#
# "-d <some_dir>" e.g. -d ~
#
# the specification is checked against:
#   - already exists?
#   - parent dir writable?
#
# returns 0/1
#
proc git_valid_dst {} {

	global repo_dst repo_name
	set rv 1

	if {$repo_dst == ""} {
		# global repo_name is guranteed to have a valid non-empty value
		# after the repo source specification is validated
		set repo_dst "./$repo_name"
	} else {
		set dst_dir [file dirname $repo_dst]
		set dst_file [file tail $repo_dst]
		if ![valid_dir $dst_dir 1] {
			p_err "problems accessing GIT destination directory?!"
			set rv 0
		}
	}
	if [file exists $repo_dst] {
		p_err "destination location already exists: '$repo_dst'?!"
		set rv 0
	}

	return $rv
}

#
# checks if supplied param valid for GIT object ID, returns 0/1
#
proc git_valid_params {} {

	global repo_params repo_src

	if {$repo_params == ""} {
		return 1
	}
	
	# git-cat-file -t 887e2ec9ecf49366a60a49b32b73825804909865
	# commit
	if {!(([string length $repo_params] == 40) &&\
	      ([regexp {^[0-9a-fA-F]+$} $repo_params]))} {
		p_err "supplied value doesn't look like a GIT object ID:\
		'$repo_params'"
		return 0
	}

	set rv 1
	set cur_dir [pwd]
        cd $repo_src

	set c "git-cat-file -t $repo_params"
	if [catch {set o [eval exec $c]}] { 
		p_err "GIT object ID: '$repo_params' not found in repo:\
		'$repo_src'"
		set rv 0

	} else {
		if {$o != "commit"} {
			p_err "supplied ID is not 'commit' type: '$o'"
			set rv 0
		} else {
			p_verb "GIT ID ok: '$repo_params'"
		}
	}

	cd $cur_dir
	return $rv 
}


#
# checks out a tree to object ID in $repo_params, creates a new branch for this
# purpose
#
proc git_branch {} {

	global repo_params repo_dst

	if {$repo_params == ""} {
		return 1
	}

	set rv 1

	set cur_dir [pwd]
        cd $repo_dst

	##
	## create branch and check out to it
	##

	# branch name
	set bn "DUTS-internal"

	set c "git-checkout -f -b $bn $repo_params"
	p_banner $c *
	if [catch {set o [eval exec $c]}] {
		p_err "failed command: '$c'"
		set rv 0
	}

	# TODO what to do with this created branch? issue an info warning?
	cd $cur_dir
	return $rv
}

#
# performs cg-clone command, returns 0/1 upon fail/success
#
proc git_clone {} {

	global shell_prompt shell_sid scm_timeout
	global repo_src repo_dst
	
	set rv 1
	set p $shell_prompt
	set spawn_id $shell_sid

	##
	## prepare cg-clone command: cg-clone <repo_src> <repo_dst>
	##  
	set c "cg-clone"
	set c_arg $repo_src
	if {$repo_dst != ""} {
		set c_arg "$c_arg $repo_dst"
	}

	##
	## execute command
	##  
	set timeout $scm_timeout 
	p_banner "$c $c_arg" *
	send -s "$c $c_arg\r"
	#
	# strings:
	# ...
	#Fetching head...^M
	#Fetching objects...^M
	#Fetching tags...^M
	#...
	#New branch: f60ba0d35e13e9dcf839d4563f9436d07468b1ef^M
	#Cloned to u-boot/ (origin /home/git/u-boot available as branch "origin")^M
	#
	#
	#cg-clone: u-boot/ already exists
	#
	expect {
		timeout {
			p_err "timed out after cg-clone"
			set rv 0
		}
		-re "already exists.*$p$" {
			#
			# this actually shouldn't happen as we checked earlier
			# for such condition, but let's handle it still - we're
			# in a multi-user environment after all and things can
			# happen behind our back...
			#
			p_err "repo already cloned"
			set rv 0
		}
		-re ".*Fetching\\ head\\.\\.\\." {
			p_verb "fetching 1: heads"
			expect {
				timeout {
					p_err "timed out on 'objects'"
					set rv 0
				}
				-re ".*Fetching\\ objects\\.\\.\\." {
					p_verb "fetching 2: objects"
					expect {
						timeout {
							p_err "timed out on cloning"
							set rv 0
						}
						-re ".*Cloned\\ to\\ .*$p$" {
							p_verb "Cloning OK"
						}
					}
				}
			}
		}
	}

	return $rv
}

#
# handler function to perform GIT operations to get local repo of
# the sources
#
proc do_git {} {

	global repo_type repo_name repo_src repo_dst repo_params
	global scm_timeout confirm TIMEOUT send_slow
	global shell_prompt shell_sid

	##
	## check tools availability:
	##  - SCM (cogito)
	##
	set tools [list "cg-clone" "git-checkout" "git-branch"]
	if ![check_host_tools tools] {
		exit1
	}
	p_verb "all tools in place, proceeding"

	##
	## validate git source repo location
	##
	if ![git_valid_src] {
		exit1
	}
	p_verb "Working with source repo: '$repo_src'"

	##
	## validate git destination location
	##
	if ![git_valid_dst] {
		exit1
	}
	p_verb "Working with destination repo: '$repo_dst'"

	##
	## validate git parameters
	##
	if ![git_valid_params] {
		exit1
	}
	p_verb "Using supplied param: '$repo_params'"

	##
	## ask user before proceeding
	##
	if {$confirm == "yes"} {
		show_params
		if ![ask_yesno "confirm to start execution? "] {
			exit
		}
	}
	p_banner "Starting GIT operation, please wait..." "#"

	##
	## spawn host shell
	##

	# assign spawn_id to global var so the shell is available outside 
        # this procedure, set other sending params
	set shell_prompt "\\$\\ "
	set shell_sid [host_bash_shell $shell_prompt]
	# expect buffer size
	match_max 16384
	set send_slow {1 .050}

	##
	## checkout
	##
	if ![git_clone] {
		process_close $shell_sid
		exit1
	}

	##
	## handle branch
	##
	if ![git_branch] {
		p_warn "repo '$repo_src' cloned successfully to\
		'$repo_dst' but subsequent GIT branch operation(s)\
		failed. Therefore the repo may be in inconsistent\
		state, please check and manage this manually."
		process_close $shell_sid
		exit1
	}

	##
	## close spawned process
	##
	process_close $shell_sid

	p_banner "Finished GIT operation, thanks for patience." "#"
}

proc do_cvs {} {
	#TODO if required
	p_err "Not implemented"
	##
	##
	## [CVS]
	## ...
	## ...
	##
	##
}

proc do_local {} {
	#TODO if required
	p_err "Not implemented"
	##
	##
	## cp -R <repo_src> <repo_dst>
	## ...
	## ...
	##
	##
}


#
# searches $scm_supported table for $repo_typer SCM name and calls associated
# handler, if found.
#
proc scm_handler {} {
	global scm_supported repo_type
	set found 0

	foreach scm $scm_supported {
		if {[lindex $scm 1] == $repo_type} {
			set found 1
			set h [lindex $scm 0]
			p_verb "calling '$h' SCM handler"
			$h
		}
	}
	if {!$found} {
		p_err "SCM type '$repo_type' not supported" 1
	}
}

#
# parameters are taken from (highest to lowest prio):
# 1. user-supplied in command line
# 2. config file
# 3. env vars
# 4. built-in defaults
#
# TODO config file
# TODO support for setting params via env vars
#

#
# parses command line parameters supplied by the user
#
proc parse_params {} {

	global argc argv
	global scm_config
	global opt_table opt_list

	set errors 0

	for {set i 0} {$i < $argc} {incr i} {
		set a [lindex $argv $i]
		
		# check if this is -<opt> element
		if [regexp {^-.*} $a] {
			# eat the leading "-"
			set o [string trimleft $a "-"]

			if [on_list opt_list $o] {
				# we have option from opt_table
				incr i
				if ![opt_process $o [lindex $argv $i]] {
					set errors 1
				}
			} else {
				# remaining -<opt> cases (special)
				switch -- \
				$o "v" {
					global verbose
					set verbose "yes"
					p_verb "verbose mode ON"

				} "b" {
					global confirm
					set confirm "no"
					p_verb "no user confirmation"
				}
			}
			continue
		}

		##
		## get config name
		##
		set scm_config $a
		p_verb "config '$scm_config'"
	}
	if {$errors > 0} {
		exit1
	}

	# TODO try loading _default config
	if {$scm_config != ""} {
		#TODO
		# load config file
	}
}


set argc [llength $argv]

##
## create global variables out of options table
##
opt_create_globals

##
## parse paramters
##
parse_params

##
## run SCM handler
##
scm_handler

##
## exit successfully if we got this far
##
exit
