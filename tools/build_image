#!/bin/env expect
#
# (C) Copyright 2006
# Wolfgang Denk, DENX Software Engineering, wd@denx.de
#
#

set BASE_DIR "/home/raj/git/duts/tools"


##
## include helper procedures
##
source "$BASE_DIR/../include/lib.tcl"


#
# ./build_image is called with the following params:
#
# [<config>] - config label
# [-t <build_type>] - id of supported build (linux-24, linux-26, uboot)
# [-n <target_name>] - TQM834x_config, TQM834x_defconfig 
# [-s <img_src>] - src tree location (/home/$USER/linuxppc_2_4_devel)
# [-d <img_dst>] - dest image location: can be filename or directory (image is
#                 copied there with default name i.e. uImage)
#                 (/tftpboot/tqm834x/uImage-24-test, /tftpboot/tqm834x/)
# [-to <timeout>] - timeout in seconds for build to complete
#
# [-m <build_tools>] - path to build tools (/opt/eldk-4.0/usr/bin/)
# [-a <build_arch>] - build arch (ppc)
# [-c <build_cross>] - cross build prefix (ppc_6xx-)
#
# [-o] - overwrite destination file, if exists
# [-nc] - 'no clean' build - from already configured source (no mrproper, 
#         config etc. targets, only uImage)
#
# [-b]	- batch mode, no user confirmation
# [-v]	- verbose
# [-h]  - help
#
#
#  examples:
# ./build_image -n TQM834x_config -t linux-24 -s /home/raj/linuxppc_2_4_devel \
#               -d /tftpboot/tqm834x -to 600
#
# ./build_image -n TQM834x_defconfig -t linux-26 -s /home/raj/linux-2.6-denx \
#               -d /tftpboot/tqm834x/uImage-26-raj -to 600
#

proc usage {} {
	#TODO
	p_banner "USAGE  "
	exit
}

# default values
set verbose "no"
set confirm "yes"
set overwrite "no"
set no_clean "no"

set build_config ""
set build_handler ""

set build_prompt ""
set build_sid ""

set TIMEOUT 10

#
# table of user interface options, each element is
# {<global_var_name> "<opt_string>" "<default_value>"}
#
set opt_table {
	{img_type "t" "linux-26"}
	{img_name "n" "TQM834x_defconfig"}
	{img_src "s" "linux-2.6-denx"}
	{img_dst "d" "/tftpboot/tqm834x/uImage-26-raj"}

	{build_timeout  "to" "600"}
	{build_tools "m" "/opt/eldk-4.0/usr/bin/"}
	{build_arch "a" "ppc"}
	{build_cross "c" "ppc_6xx-"}
}

#
# dumps params
#
proc show_params {} {
	
	global opt_table
	set globals [list]

	# create list of global vars names from opt table
	foreach o $opt_table {
		set var_name [lindex $o 0]
		lappend globals $var_name
	}

	# add other interesting global vars to the list
	lappend globals "build_config" "confirm" "verbose" "overwrite" "no_clean"

	puts "--- Settings ---"
	foreach g $globals {
		global $g
		puts "$g = '[subst $$g]'"
	}
}

#
# validates specification of destination path:
# 1. if exists: has to be (over)writable (file) dir
# 2. if doesn'n exist: parent dir has to writable
#
# dst: destination path
# ovr: applicable when existing endfile is specified in $dst - if 0 returns
#      error, if 1 checks whether file is overwritable
# dn:  default image name to look for
#
proc check_dst {dst {ovr "0"} {dn "uImage"}} {

	if {$dst == ""} {
		return 1
	}
	
	set rv 1
	if [file exists $dst] {
		# for existing paths we're only interested in file or directory
		set ft [file type $dst]
		switch -- $ft "file" {
			if {$ovr} {
				# we want to overwrite image files
				if ![file writable $dst] {
					p_err "destination file not\
					overwritable: '$dst'"
					set rv 0
				}
				
			} else {
				p_err "destination file already exists:\
				'$dst'; use -o to overwrite"
				set rv 0
			}

		} "directory" {
			if ![file writable $dst] {
				p_err "destination dir not writable: '$dst'"
				set rv 0
			} else {
				# dst specifies directory, so there can exist
				# an image with default name - check for it
				set d "$dst/$dn"
				global overwrite
				set o [expr {($overwrite == "yes") ? 1 : 0}]
				set rv [check_dst $d $o]
			}

		} default {
			p_err "file type '$ft' not supported: '$dst'"
			set rv 0
		}
		
	} else {
		# supplied path does not exist: we only accept specification
		# for a non-existing endfile (which will get created) but not
		# directory.. 
		if [regexp {/$} $dst] {
			p_err "no such directory: '$dst'"
			set rv 0
		} else {
			# check parent dir for the file
			set pd [file dirname $dst]
			if ![valid_dir $pd 1] {
				p_err "parent dir in '$dst' not valid"
				set rv 0
			} else {
				p_verb "destination '$dst' OK"
			}
		}
	}

	return $rv
}

#
# checks linux version tree: takes a peek in the main Makefile for version
# strings; returns 0/1 if doesn't/match
#
# v: version
# p: patchlevel
#
proc check_linux_ver {v p} {

	global img_src

	set rv 1
	set cmd "grep"
	set cmd_arg "-r \"VERSION = $v\" $img_src/Makefile"

	if [catch {set o [eval exec $cmd $cmd_arg]}] {
		p_verb "version does not match"
        	set rv 0
	}

	set cmd_arg "-r \"PATCHLEVEL = $p\" $img_src/Makefile"
	if [catch {set o [eval exec $cmd $cmd_arg]}] {
		p_verb "patchlevel does not match"
        	set rv 0
	}

	if {!$rv} {
		p_verb "Linux version '$v.$p' do not match, check your sources"
	} else {
		p_verb "Linux tree version '$v.$p' OK"
	}

	return $rv
}

#
# checks linux config file based on the config name core stored in $img_name,
# returns 0/1 if not/found according file
#
proc check_linux_config {} {

	global img_src img_name build_arch
	set rv 1
	
	set c $img_name
	append c "_defconfig"
	set cf "$img_src/arch/$build_arch/configs/$c"
	if {([file exists $cf]) && ([file readable $cf])} {
		p_verb "found config file '$cf'"
	} else {
		p_err "no kernel config file: '$cf'"
		set rv 0
	}

	return $rv
}

#
# validates environment for kernel build:
#
# 1. check tools
#   - path makes sense, gcc, ld etc. exist?
#
# 2. check src dir
#   - exists, writable?
#   - looks like a kernel tree?
#
# 3. check dst
#   - if dir: exists, writable?
#   - if endfile: already exists?
#
# 4. check kernel config file
#   - exists _defconfig
#
# v: version
# p: patchlevel
#
proc valid_linux_env {v p} {

	global img_type img_name img_src img_dst
	global build_tools build_arch build_cross
	global build_timeout TIMEOUT overwrite no_clean
	global env

	## 1. check tools

	##
	## set env vars: ARCH, CROSS_COMPILE
	##
	set env(ARCH) $build_arch
	set env(CROSS_COMPILE) $build_cross

	##
	## set PATH so the desired toolchain is available
	##
	if ![set_host_tool_path $build_tools] {
        	p_err "path to the build tools not accessible: '$p'?!"
		return 0
	}

	##
	## check tools availability:
	##  - a selected tool from cross build suite, let's have a look at 
	##    gcc and ld
	##
	set cmd_gcc $build_cross
	append cmd_gcc "gcc"
	set cmd_ld $build_cross
	append cmd_ld "ld"

	set tools [list $cmd_gcc $cmd_ld]
	if ![check_host_tools tools] {
		return 0
	}
	p_verb "all tools in place, proceeding"


	## 2. check src dir

	##
	## validate source dir
	##
	##  - exists, writable?
	##  - looks like a kernel tree?
	##

	# strip trailing slash
	set img_src [string trimright $img_src "/"]
	if ![valid_dir $img_src 1] {
		p_err "Problems accessing source dir?!"
		return 0
	}

	if ![check_linux_ver $v $p] {
		p_err "Doesn't look like Linux $v.$p source tree: '$img_src'?!\
		Check your -t value."
		return 0
	}
	p_verb "working with source dir: '$img_src'"

	## 3. check dst

	##
	## validate  destination location
	## - if dir: exists, writable?
	## - if endfile: already exists?
	##
	set o [expr {($overwrite == "yes") ? 1 : 0}]
	if ![check_dst $img_dst $o] {
		return 0
	}
	
	## 4. check kernel config file 
	##
	## - exists <name>_config, <name>_defconfig

	#
	# if user-provided kernel config name was '*.config' we only save the
	# core of the name for further processing when it will be personalized
	# with _config or _defconfig suffix depending on context. This is 
	# mainly due to different handling of config name in Linux 2.4
	# (make <name>_config) vs. 2.6 (make <name>_defconfig)
	# e.g. for TQM834x_defconfig save only the 'TQM834x' part
	#
	regexp {(.+)(_.*config)} $img_name in1 in2 in3]
	if [info exists in1] {
		set img_name $in2
	}

	if ![check_linux_config] {
		return 0
	}
	p_verb "using '$img_name' kernel config"
	
	##
	## verify if we can skip configuration steps
	##
	if {$no_clean == "yes"} {
		if [file exists $img_src/.config] {
			p_verb "performing 'no-clean' build, config steps will\
			be skipped"
		} else {
			p_verb "'no-clean' build specified but no .config\
			file found so doing full build anyway..."
			set no_clean "no"
		}
	}

	return 1
}

proc make_mrproper {sid p {to 180}} {
	
	set spawn_id $sid
	set rv 1

	set timeout $to
	set c "make mrproper"
	send -s "$c\r"
	#
	# error strings:
	# make: *** No rule to make target `dfdsf'.  Stop.
	#
	expect {
		timeout {
			p_err "timed out after '$c' command"
			set rv 0
		}
		-re "No\\ rule\\ to\\ make\\ target.*Stop" {
			p_err "no target"
			set rv 0
		}
		-re ".*$p$" {
			p_verb "command '$c' OK"
		}
	}

	return $rv
}

#
# parameters are taken from (highest to lowest prio):
# 1. user-supplied in command line
# 2. config file
# 3. env vars
# 4. built-in defaults
#
# TODO config file
# TODO support for setting params via env vars
#

#
# parses command line parameters supplied by the user
#
proc parse_params {} {

	global argc argv
	global build_config
	global opt_table opt_list

	set errors 0

	for {set i 0} {$i < $argc} {incr i} {
		set a [lindex $argv $i]
		
		# check if this is -<opt> element
		if [regexp {^-.*} $a] {
			# eat the leading "-"
			set o [string trimleft $a "-"]

			if [on_list opt_list $o] {
				# we have option from opt_table
				incr i
				if ![opt_process $o [lindex $argv $i]] {
					set errors 1
				}
			} else {
				# remaining -<opt> cases (special)
				switch -- \
				$o "v" {
					global verbose
					set verbose "yes"
					p_verb "verbose mode ON"

				} "b" {
					global confirm
					set confirm "no"
					p_verb "no user confirmation"
				} "o" {
					global overwrite
					set overwrite "yes"
					p_verb "overwrite existing image file"
				} "nc" {
					global no_clean 
					set no_clean "yes"
				} "h" {
					usage
				}
			}
			continue
		}

		##
		## get config name
		##
		set build_config $a
		p_verb "config '$build_config'"
	}
	if {$errors > 0} {
		exit1
	}

	# TODO try loading _default config
	if {$build_config != ""} {
		#TODO
		# load config file
	}
}

#
# skeleton build routine - uses abstracted build methods that perform specific
# steps for a given build type
#
# 1. cd to <img_src>
# 2. spawn bash shell
# 3. bld_pre (e.g. mrproper)
# 4. bld_config (e.g. make <img_name>_defconfig)
# 5. bld_image (e.g. make uImage)
# 6. bld_post (e.g. copy to <img_dst>)
# 7. close shell
#
proc build_main {} {

	global confirm no_clean send_slow img_src
	global build_prompt build_sid build_timeout

	##
	## validate build environment
	##
	if ![bld_valid_env] {
		exit1
	}
	
	##
	## ask user before proceeding
	##
	if {$confirm == "yes"} {
		show_params
		if ![ask_yesno "confirm to start execution? "] {
			return	
		}
	}

	p_banner "Starting image build, please wait." #

	set cur_dir [pwd]
	cd $img_src

	##
	## spawn bash shell on host 
	##
	
	# assign spawn_id to global var so the shell is available outside 
	# this procedure, set other sending params
	set build_prompt "\\$\\ "
	set build_sid [host_bash_shell $build_prompt]
	set send_slow {1 .050}
	# expect buffer size
	match_max 16384

	##
	## bld_pre
	##
	if {$no_clean == "yes"} {
		p_warn "no-clean build: skipping build preparation phase"
	} else {
		if ![bld_pre] {
			exit1
		}
	}

	##
	## bld_config
	##
	if {$no_clean == "yes"} {
		p_warn "no-clean build: skipping build config phase"
	} else {
		if ![bld_config] {
			exit1
		}
	}

	##
	## bld_image
	##
	if ![bld_image $build_timeout] {
		exit1
	}

	# bld_post can possibly do different things on the host, so let's get
	# back to our pwd once we're done with building the image
	cd $cur_dir
	
	##
	## bld_post
	##
	if ![bld_post] {
		exit1
	}

	##
	## close spawned shell process
	##
	process_close $build_sid

	p_banner "Finished image build, thanks for patience." #
}

#
# reads build methods implementation from external exp file: looks for
# bld_<img_type>.exp file and source if exists
#
#
# each method:
#   - assumes the shell is already open and available via globals:
#     $build_sid (spawn_id), $build_prompt
#
#   - returns 0/1 upon fail/success
#
#
#
# build methods:
#
# bld_valid_env
#   valid_linux_env 2 4, valid_uboot_env etc.
# 
# bld_pre
#   mrproper
#
# bld_config
#   make ...config
#   [make oldconfig]
#   [make dep]
#
# bld_image
#   make uImage
#   make all
#
# bld_post
#   copy to dest dir
#
# implementation of these methods is in individual files:
#
# bld_<img_type>.exp - e.g. bld_linux-26.exp, bld_linux-24.exp, bld_uboot.exp
#
proc read_build_methods {t} {
	global BASE_DIR
	set rv 1
	
	set f "$BASE_DIR/bld_$t.exp"
	if ![valid_file $f] {
		p_err "build type not supported: '$t', build methods\
		implementation file not found?!"
		return 0
	}

	if [catch {source $f} err] {
		p_err "problems with source'ing '$f'?!"
		puts "  $err"
		set rv 0
	} else {
		p_verb "using build methods implemented in file: '$f'"

		# check if the implementation file has all required methods
		set methods {
			bld_valid_env bld_pre bld_config bld_image bld_post
		}
		foreach m $methods {
			if ![proc_exists $m] {
				p_err "build method '$m' is not implemented\
				in file '$f'"
				set rv 0
			}
		}
		if $rv {
			p_verb "all build methods in place, OK"
		}
	}

	return $rv
}


set argc [llength $argv]

##
## create global variables out of options table
##
opt_create_globals

##
## parse paramters
##
parse_params


##
## find get build methods implementation
##
if ![read_build_methods $img_type] {
	exit1
}

##
## get started
##
build_main

##
## exit successfully if we got this far
##
exit
