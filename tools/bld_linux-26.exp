#
# (C) Copyright 2006, 2007 DENX Software Engineering
#
# Author: Rafal Jaworowski <raj@semihalf.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
# MA 02111-1307 USA
#

#
# implementation of bld_ methods for building Linux 2.6 kernel image
#

#
# source common file
#
set _f "$base_dir/bld_linux.exp"
if [catch {source $_f} err] {
#	p_err "problems with source'ing '$_f'?!"
	p_err $err
	exit 1
}

proc bld_valid_env {} {

	return [valid_linux_env 2 6]
}

proc bld_pre {} {
	global build_sid build_prompt

	p_banner "make mrproper" #
	return [make_mrproper $build_sid $build_prompt]
}

proc bld_config {{to 180}} {

	global build_sid build_prompt img_name
	set spawn_id $build_sid
	set p $build_prompt
	set timeout $to
	set rv 1

	set c "make $img_name"
	append c "_defconfig"
	p_banner $c #
	send -s "$c\r"
	#
	# closing strings:
	# configuration written to .config
	#
	# error strings:
	# make: *** No rule to make target `dfdsf'.  Stop.
	#
	expect {
		timeout {
			p_err "timed out after '$c' command"
			set rv 0
		}
		-re "No\\ rule\\ to\\ make\\ target.*Stop" {
			p_err "no target"
			set rv 0
		}
		-re "configuration\\ written\\ to\\ \\.config.*$p$" {
			p_verb "command '$c' OK"
		}
	}

	return $rv
}

proc bld_image {{to 600}} {

	global build_sid build_prompt img_name
	set spawn_id $build_sid
	set p $build_prompt
	set timeout $to
	set rv 1

	set c "make uImage"
	p_banner $c #
	send -s "$c\r"
	#
	# closing strings:
	# Image: arch/ppc/boot/images/uImage is ready
	# make[1]: `arch/ppc/boot/images/uImage' is up to date.
	# for arch/powerpc:
	# Entry Point:  0x00000000
	#
	# error strings:
	# make: *** No rule to make target `dfdsf'.  Stop.
	# host/ehci-q.c:185: error: invalid storage class for func
	# make[3]: *** [host/ehci-hcd.o] Error 1
	#
	# make[2]: *** [arch/powerpc/kernel/vdso32/gettimeofday.o] Error 1
	# make[1]: *** [arch/powerpc/kernel/vdso32] Error 2
	# make: *** [arch/powerpc/kernel] Error 2
	#
	expect {
		timeout {
			p_err "timed out after '$c' command"
			set rv 0
		}
		-re "No\\ rule\\ to\\ make\\ target.*Stop" {
			p_err "no target"
			set rv 0
		}
		-re ".*:\\ error:.*" {
			send_user -- "\n"
			p_err "build failed"
			set rv 0
		}
		-re ".*make.+\\ Error\\ .*" {
			send_user -- "\n"
			p_err "build failed"
			set rv 0
		}
		-re ".*boot/images/uImage\\ is\\ ready.*$p$" {
			p_verb "command '$c' OK"
		}
		-re ".*boot/images/uImage.*is\\ up\\ to\\ date.*$p$" {
			 p_verb "command '$c' OK"
		}
		-re "Entry Point:.*$p$" {
			 p_verb "command '$c' OK"
		}
	}

	return $rv
}

proc bld_post {} {

	global build_arch img_dst img_src obj_dir

	##
	## copy image to the desired location
	##
	p_banner "copy image to destination" *


	if {$build_arch == "ppc"} {
		set img_file "arch/ppc/boot/images/uImage"
	} elseif {$build_arch == "powerpc"} {
		set img_file "arch/powerpc/boot/uImage"
	} else {
		p_err "uknown build arch: '$build_arch'"
		return 0
	}

	if {[var_exists obj_dir] && ($obj_dir != "")} {
		set img_file "$obj_dir/$img_file"
	} else {
		set img_file "$img_src/$img_file"
	}

	if {$img_dst == ""} {
		p_verb "no destination location specified, nothing to do.."
	} else {
		send_user -- "Copying image to '$img_dst'\n"
		if ![host_copy $img_file $img_dst] {
			return 0
		}
		p_verb "copied '$img_file' to '$img_dst'"
	}
	return 1
}
